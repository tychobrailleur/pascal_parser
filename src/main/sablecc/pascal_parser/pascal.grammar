Package pascal_parser;


Helpers

  any_character = [0x0 .. 0xfffff];
  lf = 10;
  cr = 13;
  letter = ['a'..'z'] | ['A'..'Z'];
  digit = ['0'..'9'];

  line_terminator = lf | cr | cr lf;
  left_brace = '{';
  right_brace = '}';
  single_quote = ''';

  float = digit (digit)* '.' digit (digit)* (('E' | 'e') ('+' | '-')? digit (digit)*)?;



Tokens

  begin = 'begin';
  end = 'end';
  program = 'program';
  const = 'const';
  type = 'type';
  goto = 'goto';
  label = 'label';
  case = 'case';
  of = 'of';
  if = 'if';
  then = 'then';
  else = 'else';
  repeat = 'repeat';
  for = 'for';
  to = 'to';
  downto = 'downto';
  do = 'do';
  not = 'not';
  until = 'until';
  var = 'var';
  while = 'while';
  procedure = 'procedure';
  forward = 'forward';
  packed = 'packed';
  function = 'function';

  false = 'false';
  true = 'true';

  // types
  boolean = 'boolean';
  file = 'file';
  record = 'record';
  integer = 'integer';
  real = 'real';
  array = 'array';
  char = 'char';
  byte = 'byte';

  dot = '.';
  semicolon = ';';
  colon = ':';
  comma = ',';
  range_op = '.' '.';
  left_square_bracket = '[';
  right_square_bracket = ']';
  left_paren = '(';
  right_paren = ')';
  assign_op = ':=';
  neq_diamond = '<>';
  lt = '<';
  gt = '>';
  leq = '<=';
  geq = '>=';
  neq = '!=';
  equal = '=';
  caret = '^';

  plus = '+';
  minus = '-';
  times = '*';
  divided = '/';
  div = 'div';
  mod = 'mod';
  or = 'or';
  and = 'and';

  comment = left_brace [any_character-right_brace]* right_brace;
  blank = ' ' | '\t' | line_terminator;

  identifier = letter (letter | digit)*;
  number = digit+;
  float = float;

  // String literal.  Single-quotes are escaped by doubling them.
  string_literal = single_quote ([single_quote + single_quote] | [any_character - [''' + [cr + lf]]])* single_quote;



Ignored Tokens

  comment,
  blank;



Productions

  pascal_program = program_header
  program_decl
  program_body
  dot;

  program_header = program [program_name]:identifier semicolon;
  program_decl = program_decl_item*;
  program_decl_item = {label} label_decl
                    | {const} const_decl_block
                    | {var} var_decl_block
                    | {proc} proc_decl_block
                    | {func} func_decl_block
                    | {type} type_decl_block;
  program_body = begin statements end;

  // Label declarations
  label_decl_block = label_decl+;
  label_decl = label label_list semicolon;
  label_list = {single} number | {multiple} label_list comma number;


  // Const declarations
  const_decl_block = const const_decl_list;
  const_decl_list = const_decl+;
  const_decl = identifier equal literal_value semicolon;


  // Type declarations
  type_decl_block = type type_decl_list;
  type_decl_list = type_decl+;
  type_decl = identifier equal generic_type semicolon;

  // Var declarations
  var_decl_block = var var_decl_list;
  var_decl_list = var_decl+;
  var_decl = arg_decl semicolon;

  arg_decl = identifier_list colon generic_type;
  arg_decl_list = {simple} arg_decl
                | {multi} arg_decl_list semicolon arg_decl;

  // Procedure declarations
  proc_decl_block = proc_decl_header label_decl_block? var_decl_block? prog_decl_body semicolon;
  prog_decl_body = {fwd} forward
                 | {forward} begin statements end;
  proc_decl_header = procedure [proc_name]:identifier proc_param_decl? semicolon;
  proc_param_decl = {args} left_paren prog_arg_list right_paren;

  prog_arg_list = {simple} var? arg_decl
                | {multi} prog_arg_list semicolon arg_decl;

  // Function declarations
  func_decl_block = func_decl_header label_decl_block? var_decl_block? prog_decl_body semicolon;
  func_decl_header = function [name]:identifier func_param_decl? colon [type]:simple_type semicolon;
  func_param_decl = left_paren prog_arg_list right_paren;

  literal_value = {num} number
                | {string} string_literal
                | {float} float
                | {bool} boolean_literal
                ;

  boolean_literal = {true} true
                  | {false} false;

  range_expr = [min_val]:range_expr_limit range_op [max_val]:range_expr_limit;
  range_expr_limit = expression;

  generic_type = {packed_type} packed generic_type
               | {file_def} file_type_def
               | {record} record_def
               | {pointer} pointer_def
               | {simple} simple_type
               ;

  simple_type = {char_type} char
              | {boolean_type} boolean
              | {integer_type} integer
              | {real_type} real
              | {byte_type} byte
              | {array_type} array_type_def
              | {user_type} [type_name]:identifier
              | {range_type} range_expr
              ;
  file_type_def = file of [sub_type]:simple_type;
  pointer_def = caret simple_type;

  // Record definition
  record_def = record record_member+ end;
  record_member = {simple_member} simple_member_type semicolon
                | {case_member} case [member_type]:identifier of case_branch+ ;

  simple_member_type_list = {simple} simple_member_type
                          | {list} simple_member_type semicolon simple_member_type_list;
  simple_member_type = identifier_list colon simple_type;
  identifier_list = {simple} identifier
                  | identifier_list comma identifier;

  case_branch = {branch} case_label left_paren simple_member_type_list right_paren semicolon ;
  case_label = number colon;

  array_type_def = array left_square_bracket simple_type right_square_bracket array_of?;
  array_of = of generic_type;

  statements = {single} statement
             | {multiple} statements semicolon statement;

  statement = {without_stmt} stmt_without_trailing_stmt
            | {label} label_def statement
            | {if} if [cond]:expression then statement
            | {if_else} if [cond]:expression then [then_branch]:stmt_no_short_if else [else_branch]:statement
            | {while} while_stmt
            | {for_loop} for_loop_stmt
            ;

  stmt_no_short_if = {without_stmt} stmt_without_trailing_stmt
                   | {label} label_def stmt_no_short_if
                   | {if} if [conf]:expression then [then_branch]:stmt_no_short_if else [else_branch]:stmt_no_short_if
                   | {while} while expression do stmt_no_short_if
                   | {for} for_loop_stmt_no_short_if
                   ;
  stmt_without_trailing_stmt = {assign} assignment
                             | {goto} goto_stmt
                             | {case} case_stmt
                             | {group} statement_group
                             | {proc_def} proc_decl_block
                             | {func_def} func_decl_block
                             | {proc} procedure_invocation
                             | {proc_no_arg} proc_invocation_no_arg // Yuk.
                             | {label} label_decl
                             | {repeat} repeat_stmt
                             | {empty}
                             ;

  statement_group = begin statements end;
  label_def = number colon;
  repeat_stmt = repeat statements until expression;

  assignment = var_access assign_op expression;
  for_loop_stmt = {up} for assignment to expression do statement
                | {down} for assignment downto expression do statement;

  for_loop_stmt_no_short_if = {up} for assignment to expression do stmt_no_short_if
                            | {down} for assignment downto expression do stmt_no_short_if;
  while_stmt = while expression do statement;
  goto_stmt = goto number;
  case_stmt = case [member_type]:expression of case_stmt_branches end_case;
  case_stmt_branches = {single} case_stmt_branch
                | {mult} case_stmt_branches semicolon case_stmt_branch
                ;
  case_stmt_branch = expression_list colon statement;
  end_case = {end} end
           | {semi_end} semicolon end
           ;

  expression_list = {single} expression
                  | expression_list comma expression;


  // Expressions
  var_access = {var} identifier
             | {rec} record_access
             | {arr} array_access
             | {pointer} pointer_access;


  record_access = var_access dot [member]:identifier;
  array_access = identifier left_square_bracket expression right_square_bracket;
  pointer_access = [address]:identifier caret;

  procedure_invocation = identifier left_paren argument_list? right_paren;
  // FIXME: reduce/reduce conflicts if this is made part of procedure_invocation.
  proc_invocation_no_arg = identifier;

  argument_list = {expression} arg
                | {argument_list} argument_list comma arg;
  arg = {simple} expression
      | {width} expression colon [width]:number;

  expression = conditional_expression;
  conditional_expression = {equal_expression} equal_expression;
  equal_expression = {comparison_expression} comparison_expression
                   | {equal} equal_expression equal comparison_expression
                   | {not_equal} equal_expression neq comparison_expression
                   | {not_equal_diamond} equal_expression neq_diamond comparison_expression;
  comparison_expression = {add_expression} add_expression
                        | {lt} comparison_expression lt add_expression
                        | {gt} comparison_expression gt add_expression
                        | {leq} comparison_expression leq add_expression
                        | {geq} comparison_expression geq add_expression;
  add_expression = {mult_expression} mult_expression
                 | {plus} add_expression plus mult_expression
                 | {minus} add_expression minus mult_expression;
  mult_expression = {bool_expression} bool_expression
                  | {times} mult_expression times bool_expression
                  | {division} mult_expression divided bool_expression
                  | {mod} mult_expression mod bool_expression
                  | {div} mult_expression div bool_expression;
  bool_expression = {unary_expression} unary_expression
                  | {or} bool_expression or unary_expression
                  | {and} bool_expression and unary_expression;
  unary_expression = {val} val_expression
                   | {plus} plus unary_expression
                   | {minus} minus unary_expression
                   | {not} not unary_expression;
  val_expression = {procedure} procedure_invocation
                 | {var} var_access
                 | {literal} literal_value
                 | {expr} left_paren expression right_paren;
