Package pascal_parser;


Helpers

  any_character = [0x0 .. 0xfffff];
  lf = 10;
  cr = 13;
  letter = ['a'..'z'] | ['A'..'Z'];
  digit = ['0'..'9'];

  line_terminator = lf | cr | cr lf;
  left_brace = '{';
  right_brace = '}';
  single_quote = ''';

  float = digit (digit)* '.' digit (digit)* (('E' | 'e') ('+' | '-')? digit (digit)*)?;



Tokens

  begin = 'begin';
  end = 'end';
  program = 'program';
  const = 'const';
  type = 'type';
  goto = 'goto';
  label = 'label';
  case = 'case';
  of = 'of';
  if = 'if';
  then = 'then';
  else = 'else';
  repeat = 'repeat';
  for = 'for';
  to = 'to';
  downto = 'downto';
  do = 'do';
  not = 'not';
  until = 'until';
  var = 'var';
  while = 'while';
  procedure = 'procedure';
  forward = 'forward';
  packed = 'packed';
  function = 'function';

  false = 'false';
  true = 'true';

  // types
  boolean = 'boolean';
  file = 'file';
  record = 'record';
  integer = 'integer';
  real = 'real';
  array = 'array';
  char = 'char';
  byte = 'byte';

  dot = '.';
  semicolon = ';';
  colon = ':';
  comma = ',';
  range_op = '.' '.';
  left_square_bracket = '[';
  right_square_bracket = ']';
  left_paren = '(';
  right_paren = ')';
  assign_op = ':=';
  neq_diamond = '<>';
  lt = '<';
  gt = '>';
  leq = '<=';
  geq = '>=';
  neq = '!=';
  equal = '=';
  caret = '^';

  plus = '+';
  minus = '-';
  times = '*';
  divided = '/';
  div = 'div';
  mod = 'mod';
  or = 'or';
  and = 'and';

  comment = left_brace [any_character-right_brace]* right_brace;
  blank = ' ' | '\t' | line_terminator;

  identifier = letter (letter | digit)*;
  number = digit+;
  float = float;

  // String literal.  Single-quotes are escaped by doubling them.
  string_literal = single_quote ([single_quote + single_quote] | [any_character - [''' + [cr + lf]]])* single_quote;



Ignored Tokens

  comment,
  blank;



Productions

  pascal_program { -> pascal_program } =
      program_header
      program_body
      dot { -> New pascal_program(program_header, [program_body.statement]) };

  program_header { -> program_header } =
      program [name]:identifier semicolon { -> New program_header(name) };

  program_body { -> statement* } =
      statement_group { -> [statement_group.statement] };

  label_decl { -> statement } =
      label label_list { -> New statement.label([label_list.number]) };

  label_list { -> number* } =
      {single} number { -> [number] } |
      {multiple} label_list comma number { -> [label_list.number, number] };

  statement_group { -> statement* } =
      begin statements end { -> [statements.statement] };

  statements { -> statement* } =
      {single} statement { -> [statement.statement] } |
      {multi} [list]:statements semicolon [stmt]:statement { -> [list.statement, stmt.statement] };

  statement { -> statement? } =
      {label} label_decl { -> label_decl.statement } |
      {goto} goto_stmt { -> goto_stmt.statement } |
      {assign} assignment { -> assignment.statement } |
      {empty} { -> Null } ;

  goto_stmt { -> statement } =
      goto number { -> New statement.goto(number) };

  assignment { -> statement } =
      [var]:var_access assign_op [expr]:expression { -> New statement.assign(var.expression, expr.expression) };

  expression { -> expression } =
      conditional_expression { -> conditional_expression.expression };

  conditional_expression { -> expression } =
      {equal_expression} equal_expression { -> equal_expression.expression };

  equal_expression { -> expression } =
      {comparison_expression} comparison_expression { -> comparison_expression.expression } |
      {equal} equal_expression equal comparison_expression { -> New expression.equal(equal_expression.expression, comparison_expression.expression) } |
      {not_equal} equal_expression neq comparison_expression { -> New expression.not_equal(equal_expression.expression, comparison_expression.expression) } |
      {not_equal_diamond} equal_expression neq_diamond comparison_expression { -> New expression.not_equal_diamond(equal_expression.expression, comparison_expression.expression) };

  comparison_expression { -> expression } =
      {add_expression} add_expression { -> add_expression.expression } |
      {lt} comparison_expression lt add_expression { -> New expression.lt(comparison_expression.expression, add_expression.expression) } |
      {gt} comparison_expression gt add_expression { -> New expression.gt(comparison_expression.expression, add_expression.expression) } |
      {leq} comparison_expression leq add_expression { -> New expression.leq(comparison_expression.expression, add_expression.expression) } |
      {geq} comparison_expression geq add_expression { -> New expression.geq(comparison_expression.expression, add_expression.expression) };

  add_expression { -> expression } =
      {mult_expression} mult_expression { -> mult_expression.expression } |
      {plus} add_expression plus mult_expression { -> New expression.add(add_expression.expression, mult_expression.expression) } |
      {minus} add_expression minus mult_expression { -> New expression.sub(add_expression.expression, mult_expression.expression) };

  mult_expression { -> expression } =
      {bool_expression} bool_expression { -> bool_expression.expression } |
      {times} mult_expression times bool_expression { -> New expression.mult(mult_expression.expression, bool_expression.expression) } |
      {division} mult_expression divided bool_expression { -> New expression.div(mult_expression.expression, bool_expression.expression) } |
      {mod} mult_expression mod bool_expression { -> New expression.mod(mult_expression.expression, bool_expression.expression) }  |
      {div} mult_expression div bool_expression { -> New expression.div_div(mult_expression.expression, bool_expression.expression) } ;

  bool_expression { -> expression } =
      {unary_expression} unary_expression { -> unary_expression.expression } |
      {or} bool_expression or unary_expression { -> New expression.or(bool_expression.expression, unary_expression.expression) } |
      {and} bool_expression and unary_expression { -> New expression.and(bool_expression.expression, unary_expression.expression) };

  unary_expression { -> expression } =
      {val} val_expression { -> val_expression.expression } |
      {plus} plus unary_expression { -> New expression.plus(unary_expression.expression) } |
      {minus} minus unary_expression { -> New expression.minus(unary_expression.expression) } |
      {not} not unary_expression { -> New expression.not(unary_expression.expression) };

  val_expression { -> expression } =
      {literal} [literal]:literal_value { -> literal.expression } |
      {var} var_access { -> var_access.expression } |
      {expr} left_paren expression right_paren { -> expression.expression };

  var_access { -> expression } =
      {var} identifier { -> New expression.identifier(identifier) };

  literal_value { -> expression } =
     {num} number { -> New expression.number(number) } |
     {string} string_literal { -> New expression.string(string_literal) } |
     {true} true { -> New expression.true(true) } |
     {false} false { -> New expression.false(false) };



Abstract Syntax Tree

  pascal_program =
      program_header
      statement*;

  program_header =
      identifier;

  statement =
      {label} number* |
      {goto} number |
      {assign} [var]:expression [value]:expression;

  expression =
      {add} [left]:expression [right]:expression |
      {sub} [left]:expression [right]:expression |
      {mult} [left]:expression [right]:expression |
      {div} [left]:expression [right]:expression |
      {mod} [left]:expression [right]:expression |
      {div_div} [left]:expression [right]:expression |
      {equal} [left]:expression [right]:expression |
      {not_equal} [left]:expression [right]:expression |
      {not_equal_diamond} [left]:expression [right]:expression |
      {lt} [left]:expression [right]:expression |
      {gt} [left]:expression [right]:expression |
      {leq} [left]:expression [right]:expression |
      {geq} [left]:expression [right]:expression |
      {or} [left]:expression [right]:expression |
      {and} [left]:expression [right]:expression |
      {number} number |
      {string} string_literal |
      {float} float |
      {range} [min]:expression [max]:expression |
      {plus} [positive]:expression |
      {minus} [negative]:expression |
      {not} [not]:expression |
      {true} true |
      {identifier} identifier |
      {false} false;
