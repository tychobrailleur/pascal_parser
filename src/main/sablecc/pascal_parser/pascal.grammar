Package pascal_parser;


Helpers

  any_character = [0x0 .. 0xfffff];
  lf = 10;
  cr = 13;
  letter = ['a'..'z'] | ['A'..'Z'];
  digit = ['0'..'9'];

  line_terminator = lf | cr | cr lf;
  left_brace = '{';
  right_brace = '}';
  single_quote = ''';

  float = digit (digit)* '.' digit (digit)* (('E' | 'e') ('+' | '-')? digit (digit)*)?;



Tokens

  begin = 'begin';
  end = 'end';
  program = 'program';
  const = 'const';
  type = 'type';
  goto = 'goto';
  label = 'label';
  case = 'case';
  of = 'of';
  if = 'if';
  then = 'then';
  else = 'else';
  repeat = 'repeat';
  for = 'for';
  to = 'to';
  downto = 'downto';
  do = 'do';
  not = 'not';
  until = 'until';
  var = 'var';
  while = 'while';
  procedure = 'procedure';
  forward = 'forward';
  packed = 'packed';
  function = 'function';

  false = 'false';
  true = 'true';

  // types
  boolean = 'boolean';
  file = 'file';
  record = 'record';
  integer = 'integer';
  real = 'real';
  array = 'array';
  char = 'char';
  byte = 'byte';

  dot = '.';
  semicolon = ';';
  colon = ':';
  comma = ',';
  range_op = '.' '.';
  left_square_bracket = '[';
  right_square_bracket = ']';
  left_paren = '(';
  right_paren = ')';
  assign_op = ':=';
  neq_diamond = '<>';
  lt = '<';
  gt = '>';
  leq = '<=';
  geq = '>=';
  neq = '!=';
  equal = '=';
  caret = '^';

  plus = '+';
  minus = '-';
  times = '*';
  divided = '/';
  div = 'div';
  mod = 'mod';
  or = 'or';
  and = 'and';

  comment = left_brace [any_character-right_brace]* right_brace;
  blank = ' ' | '\t' | line_terminator;

  identifier = letter (letter | digit)*;
  number = digit+;
  float = float;

  // String literal.  Single-quotes are escaped by doubling them.
  string_literal = single_quote ([single_quote + single_quote] | [any_character - [''' + [cr + lf]]])* single_quote;



Ignored Tokens

  comment,
  blank;



Productions

  pascal_program { -> pascal_program } =
      [program_header]:program_header
      [program_decl]:program_decl
      [program_body]:program_body
      dot { -> New pascal_program(program_header, program_decl, program_body) };

  program_header { -> program_header } = program [program_name]:identifier semicolon { -> New program_header(program_name) };
  program_decl { -> program_decl } = program_decl_item* { -> New program_decl([program_decl_item]) };
  program_decl_item { -> program_decl_item } = {label} label_decl {-> label_decl.label_decl }
                    | {const} const_decl_block {-> const_decl_block.const_decl }
                    | {var} var_decl_block { -> var_decl_block.var_decl }
                    | {proc} proc_decl_block { -> proc_decl_block.proc_decl }
                    | {func} func_decl_block { -> func_decl_block.func_decl }
                    | {type} type_decl_block { -> type_decl_block.type_decl };
  program_body { -> program_body } = begin [body]:statements end { -> New program_body([body.statement]) };

  // Label declarations
  label_decl_block = label_decl+;
  label_decl { -> label_decl } = [label]:label [labels]:label_list semicolon { -> [labels.label] };
  label_list { -> label* } = {single} number { -> [number] } | {multiple} label_list comma number { -> [label_list.label]};


  // Const declarations
  const_decl_block { -> const_decl* } = const const_decl_list { -> [const_decl_list.const_decl] };
  const_decl_list { -> const_decl* } = const_decl+ { -> [const_decl] };
  const_decl { -> const_decl } = [name]:identifier equal expression semicolon { -> New  const_decl(name, expression) };


  // Type declarations
  type_decl_block { -> type_decl* } = type type_decl_list { -> [type_decl_list.type_decl] };
  type_decl_list { -> type_decl* } = type_decl+ { -> [type_decl]};
  type_decl { -> type_decl } = [name]:identifier equal [type]:generic_type semicolon { -> New type_decl(name, type.typedef)};

  // Var declarations
  var_decl_block { -> var_decl* } = var var_decl_list { -> [var_decl_list.var_decl] };
  var_decl_list { -> var_decl* } = var_decl+ { -> [var_decl] };
  var_decl { -> var_decl } = arg_decl semicolon { -> arg_decl.var_decl };

  arg_decl { -> var_decl* } = [vars]:identifier_list colon generic_type { -> New var_decl([vars.identifier], generic_type.typedef, Null) };
  arg_decl_list { -> var_decl* } = {simple} arg_decl { -> [arg_decl.var_decl] }
                | {multi} arg_decl_list semicolon arg_decl { -> [arg_decl_list.var_decl, arg_decl.var_decl]};

  // Procedure declarations
  proc_decl_block { -> proc_decl } = procedure [proc_name]:identifier proc_param_decl? [end_head]:semicolon
                                     label_decl_block? var_decl_block? prog_decl_body [end_proc]:semicolon
                                     { -> New proc_decl(proc_name, [proc_param_decl.var_decl], [prog_decl_body.statement])};
  prog_decl_body { -> statement* } = {fwd} forward { -> Null }
                 | {forward} begin statements end { -> [statements.statement] };
  proc_param_decl { -> var_decl* } = {args} left_paren prog_arg_list right_paren { -> [prog_arg_list.var_decl] };

  prog_arg_list { -> var_decl* } = {simple} var? arg_decl { -> arg_decl.var_decl }
                | {multi} prog_arg_list semicolon arg_decl { -> [prog_arg_list.var_decl, arg_decl.var_decl] };

  // Function declarations
  func_decl_block { -> func_decl } = function [name]:identifier func_param_decl? colon [type]:simple_type [end_head]:semicolon
                                     label_decl_block? var_decl_block? prog_decl_body [end_func]:semicolon
                                      { -> New proc_decl(name, [func_param_decl.var_decl], [prog_decl_body.statement])};
  func_param_decl { -> var_decl* } = left_paren prog_arg_list right_paren { -> [prog_arg_list.var_decl] };

  literal_value { -> expression } = {num} number { -> New expression.number(number) }
                | {string} string_literal { -> New expression.string(string_literal) }
                | {float} float { -> New expression.float(float) }
                | {bool} boolean_literal { -> boolean_literal.expression }
                ;

  boolean_literal { -> expression } = {true} true { -> New expression.true(true) }
                  | {false} false { -> New expression.false(false) };

  range_expr { -> range } = [min_val]:expression range_op [max_val]:expression { -> New range(min_val, max_val) };

  generic_type { -> typedef } = {packed_type} packed generic_type
               | {file_def} file_type_def
               | {record} record_def
               | {pointer} pointer_def
               | {simple} simple_type
               ;

  simple_type { -> typedef } = {char_type} char
              | {boolean_type} boolean
              | {integer_type} integer
              | {real_type} real
              | {byte_type} byte
              | {array_type} array_type_def
              | {user_type} [type_name]:identifier
              | {range_type} range_expr
              ;
  file_type_def = file of [sub_type]:simple_type;
  pointer_def = caret simple_type;

  // Record definition
  record_def = record record_member+ end;
  record_member = {simple_member} simple_member_type semicolon
                | {case_member} case [member_type]:identifier of case_branch+ ;

  simple_member_type_list = {simple} simple_member_type
                          | {list} simple_member_type semicolon simple_member_type_list;
  simple_member_type = identifier_list colon simple_type;
  identifier_list { -> identifier* } = {simple} identifier { -> [identifier] }
                  | identifier_list comma identifier { -> [identifier_list.identifier, identifier] };

  case_branch = {branch} case_label left_paren simple_member_type_list right_paren semicolon ;
  case_label = number colon;

  array_type_def = array left_square_bracket simple_type right_square_bracket array_of?;
  array_of = of generic_type;

  statements { -> statement* } = {single} statement { -> [statement] }
             | {multiple} [list]:statements semicolon [statement]:statement { -> [list.statement, statement.statement] };

  statement { -> statement } = {without_stmt} stmt_without_trailing_stmt
            | {label} label_def statement
            | {if} if [cond]:expression then statement
            | {if_else} if [cond]:expression then [then_branch]:stmt_no_short_if else [else_branch]:statement
            | {while} while_stmt
            | {for_loop} for_loop_stmt
            ;

  stmt_no_short_if { -> statement } = {without_stmt} stmt_without_trailing_stmt
                   | {label} label_def stmt_no_short_if
                   | {if} if [conf]:expression then [then_branch]:stmt_no_short_if else [else_branch]:stmt_no_short_if
                   | {while} while expression do stmt_no_short_if
                   | {for} for_loop_stmt_no_short_if
                   ;
  stmt_without_trailing_stmt { -> statement } = {assign} assignment
                             | {goto} goto_stmt
                             | {case} case_stmt
                             | {group} statement_group
                             | {proc_def} proc_decl_block
                             | {func_def} func_decl_block
                             | {proc} procedure_invocation
                             | {proc_no_arg} proc_invocation_no_arg // Yuk.
                             | {label} label_decl
                             | {repeat} repeat_stmt
                             | {empty}
                             ;

  statement_group = begin statements end;
  label_def = number colon;
  repeat_stmt = repeat statements until expression;

  assignment = var_access assign_op expression;
  for_loop_stmt = {up} for assignment to expression do statement
                | {down} for assignment downto expression do statement;

  for_loop_stmt_no_short_if = {up} for assignment to expression do stmt_no_short_if
                            | {down} for assignment downto expression do stmt_no_short_if;
  while_stmt = while expression do statement;
  goto_stmt = goto number;
  case_stmt = case [member_type]:expression of case_stmt_branches end_case;
  case_stmt_branches = {single} case_stmt_branch
                | {mult} case_stmt_branches semicolon case_stmt_branch
                ;
  case_stmt_branch = expression_list colon statement;
  end_case = {end} end
           | {semi_end} semicolon end
           ;

  expression_list = {single} expression
                  | expression_list comma expression;


  // Expressions
  var_access = {var} identifier
             | {rec} record_access
             | {arr} array_access
             | {pointer} pointer_access;


  record_access = var_access dot [member]:identifier;
  array_access = identifier left_square_bracket expression right_square_bracket;
  pointer_access = [address]:identifier caret;

  procedure_invocation = identifier left_paren argument_list? right_paren;
  // FIXME: reduce/reduce conflicts if this is made part of procedure_invocation.
  proc_invocation_no_arg = identifier;

  argument_list = {expression} arg
                | {argument_list} argument_list comma arg;
  arg = {simple} expression
      | {width} expression colon [width]:number;

  expression = conditional_expression;
  conditional_expression = {equal_expression} equal_expression;
  equal_expression = {comparison_expression} comparison_expression
                   | {equal} equal_expression equal comparison_expression
                   | {not_equal} equal_expression neq comparison_expression
                   | {not_equal_diamond} equal_expression neq_diamond comparison_expression;
  comparison_expression = {add_expression} add_expression
                        | {lt} comparison_expression lt add_expression
                        | {gt} comparison_expression gt add_expression
                        | {leq} comparison_expression leq add_expression
                        | {geq} comparison_expression geq add_expression;
  add_expression = {mult_expression} mult_expression
                 | {plus} add_expression plus mult_expression
                 | {minus} add_expression minus mult_expression;
  mult_expression = {bool_expression} bool_expression
                  | {times} mult_expression times bool_expression
                  | {division} mult_expression divided bool_expression
                  | {mod} mult_expression mod bool_expression
                  | {div} mult_expression div bool_expression;
  bool_expression = {unary_expression} unary_expression
                  | {or} bool_expression or unary_expression
                  | {and} bool_expression and unary_expression;
  unary_expression = {val} val_expression
                   | {plus} plus unary_expression
                   | {minus} minus unary_expression
                   | {not} not unary_expression;
  val_expression { -> expression } = {procedure} procedure_invocation
                 | {var} var_access
                 | {literal} [literal]:literal_value { -> literal.expression }
                 | {expr} left_paren expression right_paren;




Abstract Syntax Tree

  pascal_program =
      program_header
      program_decl
      program_body;

  program_header = [name]:identifier;
  program_decl = program_decl_item*;
  program_decl_item = {label} label label_decl*
                    | {const} const const_decl*
                    | {var} var var_decl*
                    | {proc} proc_decl*
                    | {func} func_decl*
                    | {type} type_decl*
                    ;

  program_body = statement*;

  label_decl = number*;
  const_decl = identifier expression;
  var_decl = [name]:identifier* [type]:typedef [value]:expression?;
  proc_decl = [name]:identifier [args]:var_decl* statement*;
  func_decl = [name]:identifier [return_type]:typedef statement*;
  type_decl = [name]:identifier [type]:typedef;

  typedef = {char} char
       | {bool} boolean
       | {int} integer
       | {real} real
       | {byte} byte
       | {array} identifier
       | {range} range
       | {def} identifier;

  range = [min]:expression [max]:expression;

  statement = {if} if [expression]:expression [statement]:statement
            | {if_else} if [expression]:expression [then]:statement [else]:statement
            | {forward} forward;

  expression = {add} [left]:expression [right]:expression
             | {sub} [left]:expression [right]:expression
             | {mult} [left]:expression [right]:expression
             | {div} [left]:expression [right]:expression
             | {mod} [left]:expression [right]:expression
             | {div_div} [left]:expression [right]:expression
             | {number} number
             | {float} float
             | {string} string_literal
             | {true} true
             | {false} false;
